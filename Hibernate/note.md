# Hibernate Note

## Component
1. Session-factory
   1. Information of database: url, driver, credential
   2. Setting of Hibernate: dialect, format, show option
   3. O/R Mapping

 ## flush() & commit()
flush: ensure the records in the database are consistence with the object in the Session. To do that, there are several cases:
1. commit() in the Transaction: call the flush() in the Session, then commit
2. flush() may result to SQL call, but do not commit
3. Before session.flush(), there could be flush():
   1. Executing HQL or QBC will call flush() first to get the latest record
   2. if id is auto-generated by the DB, save() will lead to INSERT to the DB immediately to ensure the existence of the ID.

flush will call a bunch of SQL but won't commit the transaction. While commit() first calls flush() and then commit the transaction, persist the changes.

However, we can still change the FlushMode to set when the flush() got called.

## refresh()
refresh the entities in the context

## Status of Object in Hibernate

1. Transient
2. Persist
3. Removed
4. Detached

Cannot change the id of object in persist statusï¼Œcause the id are used to refer to data in the DB.

* save() & persist() if the id has been set before call persist(), there will be exceptions, while save() will ignore the id if it is auto-generated by the DB.

## get() & load()
1. get() will query the data immediately, while load() is lazy-load, i.e. if the object is not used, it will not query the DB, but return a proxy object.
2. If there is no corresponding record, get() will return null, while load() throw exception.
3. load() might throw **LazyInitializationException**: when **session is closed** before proxy gets initialized.

## update()
detached object to persist object. Send UPDATE whether the **detached** object in the context is the same with the record in the DB.

.hbm.cfg set "select-before-update" to true(false by default), but it makes the update more expensive.

updating non-existed object will throw exception.

updating a detached object having the same OID with a persist OID leads to exception. Cause the context won't allow two persist object with the same OID.

## saveOrUpdate()
if OID is not null but there is no corresponding record, there will be error.

## delete()
"user_identifier_rollback" = true: after deletion the OID will be set to null.


## value & entity
If a row in the table is represented to multiple object, some column can be put in a value as a component for an entity. Value do not have ID, it can be a component of an entity.

## many to 1
When insert many before 1, the foreign key cannot be decieded, so there will be extra update after inerting the 1.

When query for many, hibernate will only query the many by default, but will not populate the 1. Only when we use the associated object, it will send the sql to query.

Set inverse = false at 1's collection, so that the 1 will not maintain the relation to avoid extra update.

When get the collection from the 1, hibernate will return its internal set(PersistentSet) instead of the set from the Java SE. There is also LazyInitializationException if session closed ahead of time.

## Properties of Cascade
Define how to manipulate the entities in the collection. If it is set to delete, all the entities in the collections will be deleted when the parent entities is deleted.

## 1 to 1
There are two way to do 1 to 1 mapping, either by the foreign key or primary key.